

// Implement the following five methods
// inserts val into BST rooted at x and returns the tree's new root
BTnode * insert(BTnode * x, int val) {
    
    if(x==NULL){ // when root is null, insert first instance of node containing val
    	x = new BTnode;
    	x->val = val;
    	x->left = NULL; //both pointers to each side are null
    	x->right = NULL; //both pointers to each side are null
    }

    if(x!=NULL){
	   if(val < x->val){ //however, if the root has a value and it's greater than val passed, recursively insert to the left (sorted)
	    	x->left = insert(x->left,val); //returns a node to x->left
	    }

	    if(val > x->val){ //vice-versa
	    	x->right = insert(x->right,val); // returns a node to x->right
	    }
	}

    return x; //returns inserted node
}


// returns true iff target in tree rooted at x
bool search(BTnode * x, int target) {
    
    while(x!=NULL){
        if(x->val == target){
            return true; //if the first node checked contains target int, return true
        }

        if(target <= x->val){
            return search(x->left,target); // search left side recursively until x->val == target, if the target is smaller/equal to value checked since right elements < left elements
        }

        if(target >= x->val){
        	return search(x->right,target); // search right side recursively until x->val == target, if the target is greater/equal to value checked since right elements > left elements
        }
    }
    return false; //if not found, return false
}

// Find the maximum value of a tree rooted at x
int findmax(BTnode * x) { //the rightest value will always be the maximum, so recurse until find the last value

    //test condition, make sure node is not empty
	if(x==NULL){
		return NULL;
	}
     // if it's not empty, check if the right leaves aren't empty
    else if(x->right==NULL){
        return x->val; // returns only once the right section has been entirely traversed, since it breaks once the right pointer is null
    }

    //recursively look for the rightmost element
    return findmax(x->right); 
}

// Find the manimum value of a tree rooted at x
int findmin(BTnode * x) {

    if(x==NULL){
        return NULL; //test condition, make sure the node is not empty
    }

    // if it's not empty, check if the left leaves aren't empty
    else if(x->left==NULL){
        return x->val; // returns only once the left section has been entirely traversed, since it breaks once the left pointer is null
    }

    // recursively look for the leftmost element
    return findmin(x->left);
}

// Given a binary tree, print its nodes in in-order

void recursePrint(BTnode * x){ //creating a separate function so that the line isn't called recursively

    if(x!=NULL){

        if(x->left!=NULL){ 
            recursePrint(x->left); //this fetches all of the left leaves which are < right leaves
            std::cout << " "; //printing a space 
        }

        std::cout << x->val; //printing the value stored in the node

        if(x->right!=NULL){
            std::cout << " "; 
            recursePrint(x->right); // this fetches all of the right leaves which are > left leaves
        }
    }
}

void printAscendOrder(BTnode * x){
    recursePrint(x); //separate function is called once the call stack has popped entirely in the recursive function (sorted order because left nodes + right nodes are joined, automatically sorted in ascending order)
    printf("\n"); //the line 
}


// You don't need to worry about these methods below
BTascii print_helper(BTnode * x);

void print(BTnode * x) {
    BTascii ret = print_helper(x);
    ret.display();
}

BTascii print_helper(BTnode * x) {
    if (x == NULL) return BTascii();
    BTascii left = print_helper(x->left);
    BTascii right = print_helper(x->right);
    char buf[25];
    sprintf(buf, "%d", x->val); return join(left, right, std::string(buf)); 

}


void postfree(BTnode * x) {
    if (x == NULL) return;
    postfree(x->left);
    postfree(x->right);
    delete x;
}
